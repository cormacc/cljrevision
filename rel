#!/usr/bin/env bb
(require '[clojure.string :as str])
(require '[babashka.cli :as cli])
(require '[babashka.fs :as fs])
;; (require '[clojure.edn :as edn])
(require '[bling.core :as bling])
(require '[babashka.process :as process])
(require '[rel.core :as core])
(require '[rel.config :as config])
(require '[rel.changelog :as changelog])

;; Commands:
;;   revision --version, -v   # print the version
;;   revision info            # Display info for all defined releasables
;;   revision major           # Increment major revision index
;;   revision minor           # Increment minor revision index
;;   revision patch           # Increment patch revision index
;;   revision changelog       # Display change log on stdout
;;   revision tag             # Commit the current revision to a local git repo and add a version tag
;;   revision chk             # Compute sha512 checksums for current build artefacts
;;   revision md5             # Compute md5sums for current build artefacts
;;   revision build           # Build releasable(s)
;;   revision archive         # Archive releasable(s)
;;   revision package         # Build and archive releasables
;;   revision deploy          # Deploy releasable(s)
;;   revision help            # Describe available commands

;; Options:
;;   [--dryrun], [--no-dryrun], [--skip-dryrun]
;;                                               # Default: false
;;   [--id=ID]

(def cli-opts
  {:entry {:alias :e
           :desc "Your dreams."
           :require true}
   :timestamp {:alias :t
               :desc "A unix timestamp, when you recorded this."
               :coerce {:timestamp :long}}})

(defn help
  [_]
  (println
   (str "revision - Release management and version control tool\n\n"
        "Available commands:\n"
        "  help                    Show this help message\n"
        "  info                    Display info for all defined releasables\n"
        "  changelog               Display change log on stdout\n"
        "  major                   Increment major revision index\n"
        "  minor                   Increment minor revision index\n"
        "  patch                   Increment patch revision index\n"
        "  build                   Build releasable(s)\n"
        "  chk                     Compute sha512 checksums for build artefacts\n"
        "  archive                 Archive artefacts to <ID>-v<REV>.zip file\n"
        "  package                 Build and archive releasables\n"
        "  commit                  Commit tracked changes using latest changelog entry\n"
        "  tag                     Create annotated git tag with version and changelog\n"
        "  deploy                  Deploy artefacts to configured destinations\n\n"
        "Planned commands (not yet implemented):\n"
        "  md5                     Compute md5sums for build artefacts\n\n"
        "Options:\n"
        "  --dryrun                Don't actually perform operations\n"
        "  --id=ID                 Target specific releasable by ID\n"
        "  --version, -v           Print the version\n")))

(defn format-revision [{:keys [major minor patch] :as _revision}]
  (core/f-string "v#{major}.#{minor}.#{patch}"))

(defn format-build-artefact [{:keys [src dest chk] :or {dest nil chk true}}]
  (let [deployed-as (or dest (last (str/split src #"/")))]
    (format "%s => %s %s" src deployed-as (if chk "CHK" "NOCHK"))))

(defn describe [releasable]
  (let [{:keys [revision changelog entries]} (config/load-revision-info releasable)
        latest-revision (first entries)
        latest-changes (str/join "\n- " (:changes latest-revision))
        build-steps (str/join "\n- " (:build_steps releasable))
        build-artefacts (str/join "\n- " (mapv #(format-build-artefact %) (:artefacts releasable)))]
    (core/f-string "#{(:id releasable)} #{(format-revision revision)} (#{(:date latest-revision)})

Changes:
- #{latest-changes}

Build steps:
- #{build-steps}

Build artefacts:
- #{build-artefacts}

(from #{(:root releasable)}/releasable.yaml)
")))



;; ============ Common Helper Functions ============

(defn format-date []
  (let [now (java.time.LocalDate/now)
        day (.getDayOfMonth now)
        month (.getMonth now)
        year (.getYear now)
        month-abbrev (case (.toString month)
                       "JANUARY" "Jan" "FEBRUARY" "Feb" "MARCH" "Mar"
                       "APRIL" "Apr" "MAY" "May" "JUNE" "Jun"
                       "JULY" "Jul" "AUGUST" "Aug" "SEPTEMBER" "Sep"
                       "OCTOBER" "Oct" "NOVEMBER" "Nov" "DECEMBER" "Dec")]
    (core/f-string "#{day} #{month-abbrev} #{year}")))

(defn get-dry-run-flag
  "Extract dry-run flag from command options, handling both forms"
  [m]
  (or (get-in m [:opts :dryrun]) (get-in m [:opts :dry-run])))

(defn get-version-string-no-v
  "Format version string without 'v' prefix"
  [{:keys [major minor patch]}]
  (core/f-string "#{major}.#{minor}.#{patch}"))

(defn load-releasable-context
  "Load releasable and revision info - common pattern across commands"
  []
  (let [releasable (config/load-default (fs/cwd))
        {:keys [revision entries] :as rev-info} (config/load-revision-info releasable)]
    {:releasable releasable
     :revision revision
     :entries entries
     :latest-entry (first entries)
     :version-string (format-revision revision)
     :version-string-no-v (get-version-string-no-v revision)}))

(defn execute-shell-command
  "Execute shell command with standard error handling"
  [& args]
  (let [result (apply process/shell {:out :string :err :string} args)]
    (when (:out result) (print (:out result)))
    (when (and (:err result) (not (str/blank? (:err result))))
      (print (:err result)))
    (if (not= 0 (:exit result))
      (assoc result
             :error true
             :exit-code (:exit result)
             :stderr (:err result))
      result)))

(defn execute-shell-or-exit
  "Execute shell command and exit on failure"
  [error-msg & args]
  (let [result (apply execute-shell-command args)]
    (when (:error result)
      (println (core/f-string "Error: #{error-msg} (exit code #{(:exit-code result)})"))
      (when (not (str/blank? (:stderr result)))
        (println (core/f-string "Error details: #{(:stderr result)}")))
      (System/exit 1))
    result))

(defn with-temp-file
  "Execute function with temporary file, ensuring cleanup"
  [filename content f]
  (try
    (spit filename content)
    (f filename)
    (catch Exception e
      (throw e))
    (finally
      (when (fs/exists? filename)
        (fs/delete filename)))))

(defn format-changelog-message
  "Format changelog entries into a message with title and body"
  [changes & {:keys [first-line-prefix] :or {first-line-prefix ""}}]
  (let [first-change (first changes)
        remaining-changes (rest changes)]
    {:summary (str first-line-prefix first-change)
     :body (when (seq remaining-changes)
             (str "Also...\n- " (str/join "\n- " remaining-changes)))
     :full (if (seq remaining-changes)
             (str first-line-prefix first-change "\n\nAlso...\n- " (str/join "\n- " remaining-changes))
             (str first-line-prefix first-change))}))

(defn require-latest-entry
  "Check for latest entry or exit with error"
  [latest-entry]
  (when-not latest-entry
    (println "Error: No changelog entries found")
    (System/exit 1)))

;; ============ End Common Helper Functions ============

(defn info [m]
  (let [{:keys [releasable]} (load-releasable-context)]
    (print (str (bling/callout {:type :info :label "Releasable Info"} (describe releasable)) "\n"))))

(defn changelog [m]
  (let [{:keys [entries]} (load-releasable-context)]
    (->> entries
         (map (fn [{:keys [version date changes] :as _entry}]
                (let [label (core/f-string "Version #{version} (#{date})")
                      change-list (str "- " (str/join "\n- " changes))]
                  (bling/callout {:type :info :label label :theme :gutter} change-list))))
         (str/join "")
         print)))

(defn read-changelog-input []
  (println "Enter changelog info (one item per line / empty line ends entry)")
  (loop [lines []]
    (let [line (read-line)]
      (if (str/blank? line)
        lines
        (recur (conj lines line))))))


(defn update-source-file [file-path old-revision new-revision new-changelog-entry]
  (let [file-content (slurp file-path)
        ;; Replace the version string
        new-content-with-version (str/replace file-content
                                              (:match old-revision)
                                              (:new-version-string new-revision))
        ;; Find and update the changelog - use more precise matching
        changelog-pattern #"(?s)(<BEGIN CHANGELOG>)(.*?)(<END CHANGELOG>)"
        match (re-find changelog-pattern new-content-with-version)]
    (if match
      (let [[full-match start-tag existing-content end-tag] match
            ;; Clean existing content and ensure proper spacing
            cleaned-existing (str/trim existing-content)
            ;; Build new changelog with proper structure
            new-changelog-content (str "\n" new-changelog-entry "\n" cleaned-existing "\n")
            ;; Replace the entire changelog section
            updated-content (str/replace new-content-with-version
                                         changelog-pattern
                                         (str start-tag new-changelog-content end-tag))]
        (spit file-path updated-content)
        true)
      false)))

(defn update-version-and-changelog [increment-fn]
  (let [releasable (config/load-default (fs/cwd))
        {:keys [revision]} (config/load-revision-info releasable)
        changelog-lines (read-changelog-input)]
    (if (empty? changelog-lines)
      (println "No changelog entries provided. Version not updated.")
      (let [new-revision (increment-fn revision)
            new-version (core/f-string "#{(:major new-revision)}.#{(:minor new-revision)}.#{(:patch new-revision)}")
            current-date (format-date)
            comment-prefix (get-in releasable [:revision :comment_prefix])
            new-changelog-entry (changelog/format-entry new-version current-date changelog-lines comment-prefix)
            file-path (fs/path (:root releasable) (get-in releasable [:revision :src]))]
        (if (update-source-file (str file-path) revision new-revision new-changelog-entry)
          (println (core/f-string "Successfully updated version to #{new-version} and added changelog entry."))
          (println "Failed to update source file - could not locate changelog section."))))))

(defn patch [m]
  (update-version-and-changelog core/increment-patch-version))

(defn minor [m]
  (update-version-and-changelog core/increment-minor-version))

(defn major [m]
  (update-version-and-changelog core/increment-major-version))

(defn build [m]
  (let [{:keys [releasable]} (load-releasable-context)
        build-steps (:build_steps releasable)]
    (if (empty? build-steps)
      (println "No build steps defined in releasables.yaml")
      (do
        (println (core/f-string "Executing #{(count build-steps)} build step(s)..."))
        ;; Create a script that prefixes each step with an echo of the step description
        (let [prefixed-steps (map-indexed
                              (fn [index step]
                                (let [step-desc (core/f-string "[#{(inc index)}/#{(count build-steps)}] #{step}")]
                                  (core/f-string "echo '#{step-desc}' && #{step}")))
                              build-steps)
              combined-script (str/join " && " prefixed-steps)]
          (try
            (let [result (process/shell {:out :string :err :string} "sh" "-c" combined-script)]
              (when (:out result) (print (:out result)))
              (when (and (:err result) (not (str/blank? (:err result))))
                (print (:err result)))
              (when (not= 0 (:exit result))
                (println (core/f-string "Error: Build failed with exit code #{(:exit result)}"))
                (when (not (str/blank? (:err result)))
                  (println (core/f-string "Error details: #{(:err result)}")))
                (System/exit 1)))
            (catch Exception e
              (println (core/f-string "Error executing build: #{(.getMessage e)}"))
              (System/exit 1))))
        (println "All build steps completed successfully!")))))

(defn calc-checksum [src-file]
  (if (fs/exists? (fs/path src-file))
    (let [{:keys [exit out] :as _result} (process/shell {:out :string :err :string}
                                                        (core/f-string "sha512sum #{src-file}"))]
      (if (= 0 exit)
        out
        (throw (ex-info "Error: Failed to generate checksum for #{src-file}" {:file src-file}))))
    (throw (ex-info (core/f-string "Warning: Source file #{src-file} not found, skipping") {:file src-file}))))

(defn chk [m]
  (let [{:keys [releasable]} (load-releasable-context)
        artefacts (:artefacts releasable)]
    (if (empty? artefacts)
      (println "No artefacts defined in releasables.yaml")
      (do
        (println (core/f-string "Calculating SHA512 checksums for #{(count artefacts)} artefact(s)..."))
        (doseq [{:keys [src chk] :as artefact} artefacts]
          (if (not= false chk)
            (try
              (let [checksum (calc-checksum src)]
                (print checksum))
              (catch Exception e
                (println (core/f-string "Error generating checksum: #{(.getMessage e)}"))))
            (println (core/f-string "... bypassing checksum calculation for #{src} ..."))))))))

(defn- deploy-exec-steps
  "Execute custom deployment steps from target configuration"
  [steps]
  (println "Executing custom deployment steps...")
  (let [combined-script (str/join " && " steps)]
    (execute-shell-or-exit "Deployment step failed" "sh" "-c" combined-script)))

(defn determine-dest-filename
  "Determine the destination filename for an artifact.
  If the artifact has a :dest key, use it and replace <REV> placeholders with version-string.
  Otherwise, use the source filename."
  [artefact src-filename version-string]
  (if-let [custom-dest (:dest artefact)]
    (str/replace custom-dest "<REV>" version-string)
    src-filename))

(defn- deploy-artefact-to
  "Deploy a single artifact to the destination directory"
  [artefact dest version-string]
  (let [{:keys [src chk]} artefact
        src-path (fs/path src)
        src-filename (fs/file-name src)
        dest-file (determine-dest-filename artefact src-filename version-string)
        dest-path (fs/path dest dest-file)
        dest-chk (str dest-path ".sha512")]

    (println (core/f-string "  Copying #{src} => #{dest}/#{dest-file}"))
    (try
      (fs/copy src-path dest-path {:replace-existing true})
      (when (not= false chk)
        (println (core/f-string "  ... checksum => #{dest-chk}"))
        (let [checksum (calc-checksum src)]
          (spit dest-chk checksum)))
      (catch Exception e
        (println (core/f-string "Error deploying #{src}: #{(.getMessage e)}"))
        (System/exit 1)))))

(defn- deploy-to
  "Deploy artifacts to a single target destination"
  [target artefacts version-string]
  (if (:steps target)
    (deploy-exec-steps (:steps target))

    (when-let [dest (:dest target)]
      (println (core/f-string "Deploying to #{dest}"))

      (try
        (fs/create-dirs dest)
        (catch Exception e
          (println (core/f-string "Error creating destination directory #{dest}: #{(.getMessage e)}"))
          (System/exit 1)))

      (doseq [artefact artefacts]
        (deploy-artefact-to artefact dest version-string)))))

(defn deploy [m]
  (let [{:keys [releasable version-string-no-v]} (load-releasable-context)
        artefacts (:artefacts releasable)
        deploy-targets (:deploy releasable)]
    (cond
      (empty? artefacts)
      (println "No artefacts defined in releasables.yaml")

      (empty? deploy-targets)
      (println "No deployment destinations defined in releasables.yaml")

      :else
      (do
        (println (core/f-string "Deploying #{(count artefacts)} artefact(s) to #{(count deploy-targets)} destination(s)..."))
        (doseq [target deploy-targets]
          (deploy-to target artefacts version-string-no-v))
        (println "Deployment completed successfully!")))))

(defn archive [m]
  (let [{:keys [releasable version-string-no-v]} (load-releasable-context)
        artefacts (:artefacts releasable)
        archive-dest (:archive releasable)
        releasable-id (:id releasable)
        archive-filename (core/f-string "#{releasable-id}-v#{version-string-no-v}.zip")
        archive-path (fs/path archive-dest archive-filename)]

    (cond
      (empty? artefacts)
      (println "No artefacts defined in releasables.yaml")

      (nil? archive-dest)
      (println "No archive destination defined in releasables.yaml (missing :archive key)")

      :else
      (do
        (println (core/f-string "Archiving #{(count artefacts)} artefact(s) to #{archive-path}..."))

        ;; Create archive destination directory
        (try
          (fs/create-dirs archive-dest)
          (catch Exception e
            (println (core/f-string "Error creating archive directory #{archive-dest}: #{(.getMessage e)}"))
            (System/exit 1)))

        ;; Delete existing archive if it exists
        (when (fs/exists? archive-path)
          (fs/delete archive-path))

        ;; Create zip archive with artifacts
        (doseq [{:keys [src chk] :as artefact} artefacts]
          (let [src-path (fs/path src)
                src-filename (fs/file-name src)
                dest-file (determine-dest-filename artefact src-filename version-string-no-v)
                chk-file (str dest-file ".sha512")]

            (if (fs/exists? src-path)
              (do
                (println (core/f-string "  Adding #{src} as #{dest-file}"))
                (try
;; Add the main file to zip
                  (let [parent-dir (or (fs/parent src-path) ".")
                        zip-cmd (core/f-string "cd #{parent-dir} && zip -u #{archive-path} #{(fs/file-name src-path)}")]
                    (when (not= 0 (:exit (process/shell {:out :string :err :string} "sh" "-c" zip-cmd)))
                      (throw (ex-info "Failed to add file to zip" {:file src}))))

                  ;; Add checksum file if required
                  (when (not= false chk)
                    (println (core/f-string "    Adding checksum #{chk-file}"))
                    (let [checksum (calc-checksum src)
                          temp-chk-file (str "/tmp/" (fs/file-name src) ".sha512")]
                      (spit temp-chk-file checksum)
                      (let [chk-zip-cmd (core/f-string "zip -j -u #{archive-path} #{temp-chk-file}")]
                        (when (not= 0 (:exit (process/shell {:out :string :err :string} "sh" "-c" chk-zip-cmd)))
                          (throw (ex-info "Failed to add checksum to zip" {:file temp-chk-file}))))
                      (fs/delete temp-chk-file)))

                  (catch Exception e
                    (println (core/f-string "Error archiving #{src}: #{(.getMessage e)}"))
                    (System/exit 1))))

              (do
                (println (core/f-string "  Warning: Source file #{src} not found, skipping"))))))

        (println (core/f-string "Archive created successfully: #{archive-path}"))

        ;; Generate SHA512 checksum for the archive
        (let [archive-chk-path (str archive-path ".sha512")]
          (try
            (println (core/f-string "Generating checksum: #{archive-chk-path}"))
            (let [checksum (calc-checksum (str archive-path))]
              (spit archive-chk-path checksum)
              (println (core/f-string "Checksum generated: #{archive-chk-path}")))
            (catch Exception e
              (println (core/f-string "Warning: Failed to generate archive checksum: #{(.getMessage e)}")))))))))

(defn package [m]
  (println "Building and archiving releasables...")
  (build m)
  (archive m)
  (println "Package operation completed successfully!"))

(defn commit [m]
  (let [{:keys [latest-entry version-string]} (load-releasable-context)
        dry-run? (get-dry-run-flag m)]

    (require-latest-entry latest-entry)

    (let [changes (:changes latest-entry)
          msg-parts (format-changelog-message changes :first-line-prefix (str version-string " - "))
          full-commit-msg (:full msg-parts)]

        (if dry-run?
          (do
            (println "DRY RUN: Would commit the following changes:")
            (println)
            (println "Commit message:")
            (println "================")
            (println full-commit-msg)
            (println)
            (println "Files to be committed:")
            (println "======================")

            ;; Show what files would be committed
            (let [status-result (process/shell {:out :string :err :string} "git" "status" "--porcelain")]
              (if (= 0 (:exit status-result))
                (let [status-lines (str/split-lines (:out status-result))
                      modified-files (filter #(re-find #"^[M ]M " %) status-lines)]
                  (if (seq modified-files)
                    (doseq [line modified-files]
                      (let [filename (subs line 3)]
                        (println (core/f-string "  M #{filename}"))))
                    (println "  No modified tracked files found")))
                (println "  Error: Could not get git status")))

            (println)
            (println "Run without --dry-run to perform the actual commit."))

          ;; Normal commit logic
          (do
            (println (core/f-string "Committing changes with version #{version-string}..."))
            (println (core/f-string "Summary: #{(:summary msg-parts)}"))

            (with-temp-file "commit_msg_temp.txt" full-commit-msg
              (fn [commit-msg-file]
                ;; Add all tracked files and commit
                (execute-shell-or-exit "Failed to add files" "git" "add" "-u")
                (execute-shell-or-exit "Failed to commit" "git" "commit" "-F" commit-msg-file)
                (println "Commit completed successfully!"))))))))

(defn tag [m]
  (let [{:keys [latest-entry version-string revision]} (load-releasable-context)
        dry-run? (get-dry-run-flag m)]

    (require-latest-entry latest-entry)

    (let [changes (:changes latest-entry)
          date (:date latest-entry)
          tag-name version-string
          tag-title (core/f-string "Version #{(:major revision)}.#{(:minor revision)}.#{(:patch revision)} (#{date})")
          tag-body (str "- " (str/join "\n- " changes))
          full-tag-msg (str tag-title "\n\n" tag-body)]

        (if dry-run?
          (do
            (println "DRY RUN: Would create the following tag:")
            (println)
            (println (core/f-string "Tag name: #{tag-name}"))
            (println)
            (println "Tag annotation:")
            (println "================")
            (println full-tag-msg)
            (println)
            (println "Run without --dry-run to create the actual tag."))

          (do
            (println (core/f-string "Creating annotated git tag #{tag-name}..."))

            (with-temp-file "tag_msg_temp.txt" full-tag-msg
              (fn [tag-msg-file]
                (let [result (execute-shell-command "git" "tag" "-a" tag-name "-F" tag-msg-file)]
                  (cond
                    (= 0 (:exit result))
                    (println (core/f-string "Tag #{tag-name} created successfully!"))

                    (re-find #"already exists" (:stderr result))
                    (do (println (core/f-string "Error: Tag #{tag-name} already exists"))
                        (println (core/f-string "Use 'git tag -d #{tag-name}' to delete it first if you want to recreate it"))
                        (System/exit 1))

                    :else
                    (do (println (core/f-string "Error: Failed to create tag (exit code #{(:exit-code result)})"))
                        (when (not (str/blank? (:stderr result)))
                          (println (core/f-string "Error details: #{(:stderr result)}")))
                        (System/exit 1)))))))))))

(def table
  [{:cmds [] :fn help}
   {:cmds ["info"] :fn info}
   {:cmds ["changelog"] :fn changelog}
   {:cmds ["major"] :fn major}
   {:cmds ["minor"] :fn minor}
   {:cmds ["patch"] :fn patch}
   {:cmds ["build"] :fn build}
   {:cmds ["chk"] :fn chk}
   {:cmds ["archive"] :fn archive}
   {:cmds ["package"] :fn package}
   {:cmds ["commit"] :fn commit}
   {:cmds ["tag"] :fn tag}
   {:cmds ["deploy"] :fn deploy}])

(defn -main [args]
  (cli/dispatch table args {:coerce {:dry-run :boolean :dryrun :boolean}}))

(-main *command-line-args*)
