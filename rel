#!/usr/bin/env bb
(require '[clojure.string :as str])
(require '[babashka.cli :as cli])
(require '[babashka.fs :as fs])
;; (require '[clojure.edn :as edn])
(require '[clj-yaml.core :as yaml])
(require '[clojure.pprint :refer [pprint]])
(require '[bling.core :refer [bling callout]])
(require '[babashka.process :as process])
(require '[rel.core :as core])

;; Commands:
;;   revision --version, -v   # print the version
;;   revision info            # Display info for all defined releasables
;;   revision major           # Increment major revision index
;;   revision minor           # Increment minor revision index
;;   revision patch           # Increment patch revision index
;;   revision changelog       # Display change log on stdout
;;   revision tag             # Commit the current revision to a local git repo and add a version tag
;;   revision chk             # Compute sha512 checksums for current build artefacts
;;   revision md5             # Compute md5sums for current build artefacts
;;   revision build           # Build releasable(s)
;;   revision archive         # Archive releasable(s)
;;   revision package         # Build and archive releasables
;;   revision deploy          # Deploy releasable(s)
;;   revision help            # Describe available commands

;; Options:
;;   [--dryrun], [--no-dryrun], [--skip-dryrun]
;;                                               # Default: false
;;   [--id=ID]

;; (defn read-entries
;;   []
;;   (if (fs/exists? ENTRIES-LOCATION)
;;     (edn/read-string (slurp ENTRIES-LOCATION))
;;     []))

;; (defn add-entry
;;   [{:keys [opts]}]
;;   (let [entries (read-entries)]
;;     (spit ENTRIES-LOCATION
;;           (conj entries
;;                 (merge {:timestamp (System/currentTimeMillis)} ;; default timestamp
;;                        opts)))))

;; From https://gist.github.com/blacktaxi/1676575
(defmacro f-string [^String string]
  (let [-re #"#\{(.*?)\}"
        fstr (clojure.string/replace string -re "%s")
        fargs (map #(read-string (second %)) (re-seq -re string))]
    `(format ~fstr ~@fargs)))

(def cli-opts
  {:entry     {:alias   :e
               :desc    "Your dreams."
               :require true}
   :timestamp {:alias  :t
               :desc   "A unix timestamp, when you recorded this."
               :coerce {:timestamp :long}}})

(def yaml-filename "releasables.yaml")

(defn find-yaml-root [dir]
  (println (str "Searching " dir " for " yaml-filename))
  (let [candidate (fs/path dir yaml-filename)
        parent (fs/parent dir)]
    (if (fs/exists? candidate)
      dir
      (if (empty? parent)
        nil
        (recur parent)))))

(defn load-definition [file-path]
  (let [yaml-raw (slurp (str file-path))
        ;; For some reason I adopted a :key: convention with multiple colons....
        yaml-data (str/replace yaml-raw #":(\S+):" "$1:")]
    (yaml/parse-string yaml-data)))

;; Now using core/parse-revision from rel.core namespace

(def changelog-matcher #"(?s)<BEGIN CHANGELOG>(.+)<END CHANGELOG>")
(defn extract-changelog [text comment-prefix]
  (let [prefix-matcher (re-pattern (str "(?m)^" comment-prefix " ?"))]
    (-> (re-find changelog-matcher text)
        second
        (str/replace prefix-matcher ""))))

(def entry-matcher #"(?m)^Version (\S+) \((.+)\)\n((?:- .+\n)+)")
(defn parse-changelog-entries [changelog-text]
  (->> (re-seq entry-matcher changelog-text)
       (mapv (fn [[match version date changes]]
               {:version version
                :date date
                :changes (-> (str/replace changes #"(?m)^- " "")
                             (str/split #"\n"))
                :full-text match}))))

(defn load-revision-info [{:keys [root revision] :as _releasable}]
  (let [file-path-rel (:src revision)
        file-path (fs/path root file-path-rel)
        file-content (slurp (str file-path))
        rev (core/parse-revision file-content (:regex revision))
        changelog (extract-changelog file-content (:comment_prefix revision))
        entries (parse-changelog-entries changelog)]
    {:revision rev
     :changelog changelog
     :entries entries}))

(defn load-all [path]
  (let [root (find-yaml-root path)
        definition (load-definition (fs/path root yaml-filename))]
    (assoc definition :root root)))

(defn load-default [path]
  (let [{:keys [root releasables]} (load-all path)]
    ;;Assume releasable root is project root for now...
    (assoc (first releasables) :root root)))

(defn help
  [_]
  (println
   (str "revision - Release management and version control tool\n\n"
        "Available commands:\n"
        "  help                    Show this help message\n"
        "  info                    Display info for all defined releasables\n"
        "  changelog               Display change log on stdout\n"
        "  major                   Increment major revision index\n"
        "  minor                   Increment minor revision index\n"
        "  patch                   Increment patch revision index\n"
        "  build                   Build releasable(s)\n\n"
        "Planned commands (not yet implemented):\n"
        "  tag                     Commit current revision and add version tag\n"
        "  chk                     Compute sha512 checksums for build artefacts\n"
        "  md5                     Compute md5sums for build artefacts\n"
        "  archive                 Archive releasable(s)\n"
        "  package                 Build and archive releasables\n"
        "  deploy                  Deploy releasable(s)\n\n"
        "Options:\n"
        "  --dryrun                Don't actually perform operations\n"
        "  --id=ID                 Target specific releasable by ID\n"
        "  --version, -v           Print the version\n")))

(defn format-revision [{:keys [major minor patch] :as _revision}]
  ;;FIXME: Coerce these as ints after loading...
  (f-string "v#{major}.#{minor}.#{patch}"))

(defn format-build-artefact [{:keys [src dest chk] :or {dest nil chk true}}]
  (let [deployed-as (or dest (last (str/split src #"/")))]
    (format "%s => %s %s" src deployed-as (if chk "CHK" "NOCHK"))))

(defn describe [releasable]
  (let [{:keys [revision changelog entries]} (load-revision-info releasable)
        latest-revision (first entries)
        latest-changes (str/join "\n- " (:changes latest-revision))
        build-steps (str/join "\n- " (:build_steps releasable))
        build-artefacts (str/join "\n- " (mapv  #(format-build-artefact %) (:artefacts releasable)))]
    (f-string "#{(:id releasable)} #{(format-revision revision)} (#{(:date latest-revision)})

Changes:
- #{latest-changes}

Build steps:
- #{build-steps}

Build artefacts:
- #{build-artefacts}

(from #{(:root releasable)}/releasable.yaml)
")))

(defn info [m]
  (let [releasable (load-default (fs/cwd))]
    (print (str (callout {:type :info :label "Releasable Info"} (describe releasable)) "\n"))))

(defn changelog [m]
  (let [releasable (load-default (fs/cwd))
        {:keys [entries]} (load-revision-info releasable)]
    (->> entries
         (map (fn [{:keys [version date changes] :as _entry}]
                (let [label (f-string "Version #{version} (#{date})")
                      change-list (str "- " (str/join "\n- " changes))]
                  (callout {:type :info :label label} change-list))))
         (str/join "")
         print)))

(defn read-changelog-input []
  (println "Enter changelog info (one item per line / empty line ends entry)")
  (loop [lines []]
    (let [line (read-line)]
      (if (str/blank? line)
        lines
        (recur (conj lines line))))))

(defn format-date []
  (let [now (java.time.LocalDate/now)
        day (.getDayOfMonth now)
        month (.getMonth now)
        year (.getYear now)
        month-abbrev (case (.toString month)
                       "JANUARY" "Jan" "FEBRUARY" "Feb" "MARCH" "Mar"
                       "APRIL" "Apr" "MAY" "May" "JUNE" "Jun"
                       "JULY" "Jul" "AUGUST" "Aug" "SEPTEMBER" "Sep"
                       "OCTOBER" "Oct" "NOVEMBER" "Nov" "DECEMBER" "Dec")]
    (f-string "#{day} #{month-abbrev} #{year}")))

;; Now using increment functions from rel.core namespace

(defn format-changelog-entry [version date changelog-lines comment-prefix]
  (let [header (f-string "#{comment-prefix} Version #{version} (#{date})")
        change-lines (map #(str comment-prefix " - " %) changelog-lines)
        blank-line (str comment-prefix)]
    (str/join "\n" (concat [blank-line header] change-lines))))

(defn update-source-file [file-path old-revision new-revision new-changelog-entry]
  (let [file-content (slurp file-path)
        ;; Replace the version string
        new-content-with-version (str/replace file-content
                                              (:match old-revision)
                                              (:new-version-string new-revision))
        ;; Find and update the changelog - use more precise matching
        changelog-pattern #"(?s)(<BEGIN CHANGELOG>)(.*?)(<END CHANGELOG>)"
        match (re-find changelog-pattern new-content-with-version)]
    (if match
      (let [[full-match start-tag existing-content end-tag] match
            ;; Clean existing content and ensure proper spacing
            cleaned-existing (str/trim existing-content)
            ;; Build new changelog with proper structure
            new-changelog-content (str "\n" new-changelog-entry "\n" cleaned-existing "\n")
            ;; Replace the entire changelog section
            updated-content (str/replace new-content-with-version
                                         changelog-pattern
                                         (str start-tag new-changelog-content end-tag))]
        (spit file-path updated-content)
        true)
      false)))

(defn update-version-and-changelog [increment-fn]
  (let [releasable (load-default (fs/cwd))
        {:keys [revision]} (load-revision-info releasable)
        changelog-lines (read-changelog-input)]
    (if (empty? changelog-lines)
      (println "No changelog entries provided. Version not updated.")
      (let [new-revision (increment-fn revision)
            new-version (f-string "#{(:major new-revision)}.#{(:minor new-revision)}.#{(:patch new-revision)}")
            current-date (format-date)
            comment-prefix (get-in releasable [:revision :comment_prefix])
            new-changelog-entry (format-changelog-entry new-version current-date changelog-lines comment-prefix)
            file-path (fs/path (:root releasable) (get-in releasable [:revision :src]))]
        (if (update-source-file (str file-path) revision new-revision new-changelog-entry)
          (println (f-string "Successfully updated version to #{new-version} and added changelog entry."))
          (println "Failed to update source file - could not locate changelog section."))))))

(defn patch [m]
  (update-version-and-changelog core/increment-patch-version))

(defn minor [m]
  (update-version-and-changelog core/increment-minor-version))

(defn major [m]
  (update-version-and-changelog core/increment-major-version))

(defn build [m]
  (let [releasable (load-default (fs/cwd))
        build-steps (:build_steps releasable)]
    (if (empty? build-steps)
      (println "No build steps defined in releasables.yaml")
      (do
        (println (f-string "Executing #{(count build-steps)} build step(s)..."))
        ;; Create a script that prefixes each step with an echo of the step description
        (let [prefixed-steps (map-indexed 
                               (fn [index step]
                                 (let [step-desc (f-string "[#{(inc index)}/#{(count build-steps)}] #{step}")]
                                   (f-string "echo '#{step-desc}' && #{step}")))
                               build-steps)
              combined-script (str/join " && " prefixed-steps)]
          (try
            (let [result (process/shell {:out :string :err :string} "sh" "-c" combined-script)]
              (when (:out result) (print (:out result)))
              (when (and (:err result) (not (str/blank? (:err result))))
                (print (:err result)))
              (when (not= 0 (:exit result))
                (println (f-string "Error: Build failed with exit code #{(:exit result)}"))
                (when (not (str/blank? (:err result)))
                  (println (f-string "Error details: #{(:err result)}")))
                (System/exit 1)))
            (catch Exception e
              (println (f-string "Error executing build: #{(.getMessage e)}"))
              (System/exit 1))))
        (println "All build steps completed successfully!")))))

(def table
  [{:cmds [] :fn help}
   {:cmds ["info"] :fn info}
   {:cmds ["changelog"] :fn changelog}
   {:cmds ["major"] :fn major}
   {:cmds ["minor"] :fn minor}
   {:cmds ["patch"] :fn patch}
   {:cmds ["build"] :fn build}])


(defn -main [args]
  (cli/dispatch table args))

(-main *command-line-args*)
